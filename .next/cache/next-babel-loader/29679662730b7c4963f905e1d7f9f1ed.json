{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { takeLatest, takeEvery, call, put, fork } from 'redux-saga/effects';\nimport * as actions from '../actions/users';\nimport * as api from '../api/users';\nimport { v4 as uuidv4 } from 'uuid';\n\nfunction* loginUser({\n  payload\n}) {\n  try {\n    const result = yield call(api.loginUser, payload);\n    yield put(actions.getUserSuccess(_objectSpread({}, result.data.user)));\n  } catch (error) {\n    const errorData = error.response.data;\n\n    if (errorData.error === 'Password is incorrect.') {\n      yield put(actions.loginUserError({\n        error: 'Sai mật khẩu' + uuidv4()\n      }));\n    } else if (errorData.error === 'User not found.') {\n      yield put(actions.loginUserError({\n        error: 'Không tìm thấy người dùng' + uuidv4()\n      }));\n    } else if (errorData.error === 'Cannot use normal login.') {\n      yield put(actions.loginUserError({\n        error: 'Không thể đăng nhập bằng cách này' + uuidv4()\n      }));\n    } else {\n      yield put(actions.loginUserError({\n        error: errorData.error\n      }));\n    }\n  }\n}\n\nfunction* watchLoginUser() {\n  yield takeLatest(actions.Types.LOGIN_USER, loginUser);\n}\n\nfunction* getUser() {\n  try {\n    const result = yield call(api.getUser);\n    yield put(actions.getUserSuccess(_objectSpread({}, result.data.user)));\n  } catch (e) {\n    // yield put(actions.getUserSuccess({ ...result.data.user }));\n    yield put(actions.getUserError());\n  }\n}\n\nfunction* watchGetUsersRequest() {\n  yield takeEvery(actions.Types.GET_USER, getUser);\n}\n\nfunction* createUser({\n  payload\n}) {\n  try {\n    const result = yield call(api.createUser, payload);\n    yield put(actions.getUserSuccess(_objectSpread({}, result.data.user)));\n  } catch (error) {\n    console.log(error.response);\n  }\n}\n\nfunction* loginByGoogle({\n  payload\n}) {\n  try {\n    const result = yield call(api.loginByGoogle, payload);\n    yield put(actions.getUserSuccess(_objectSpread({}, result.data.user)));\n  } catch (error) {\n    const errorData = error.response.data;\n\n    if (errorData.error === 'Email is already in use.') {\n      yield put(actions.loginByGoogleError({\n        error: 'Email đã tồn tại'\n      }));\n    } else {\n      yield put(actions.loginByGoogleError({\n        error: 'Lỗi bất ngờ đã xảy ra'\n      }));\n    }\n  }\n}\n\nfunction* watchCreateUser() {\n  yield takeLatest(actions.Types.CREATE_USER, createUser);\n}\n\nfunction* watchLoginByGoogle() {\n  yield takeLatest(actions.Types.LOGIN_BY_GOOGLE, loginByGoogle);\n}\n\nfunction* logOutUser() {\n  yield call(api.logoutUser);\n  yield call(getUser);\n}\n\nfunction* watchLogOutUser() {\n  yield takeLatest(actions.Types.LOG_OUT_USER, logOutUser);\n}\n\nfunction* loginByFacebook({\n  payload\n}) {\n  try {\n    const result = yield call(api.loginByFacebook, payload);\n    yield put(actions.getUserSuccess(_objectSpread({}, result.data.user)));\n  } catch (error) {\n    const errorData = error.response.data;\n\n    if (errorData.error === 'Email is already in use.') {\n      yield put(actions.loginByFacebookError({\n        error: 'Email đã tồn tại'\n      }));\n    } else {\n      yield put(actions.loginByFacebookError({\n        error: 'Lỗi bất ngờ đã xảy ra'\n      }));\n    }\n  }\n}\n\nfunction* watchLoginByFacebook() {\n  yield takeLatest(actions.Types.LOGIN_BY_FACEBOOK, loginByFacebook);\n}\n\nconst userSagas = [fork(watchLoginUser), fork(watchGetUsersRequest), fork(watchCreateUser), fork(watchLoginByGoogle), fork(watchLogOutUser), fork(watchLoginByFacebook)];\nexport default userSagas;","map":null,"metadata":{},"sourceType":"module"}